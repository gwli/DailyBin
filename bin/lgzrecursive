#!/usr/bin/env python
# -*- coding:utf-8 -*-
import os
import logging
import subprocess
logging.basicConfig(level=logging.DEBUG)
logger=logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
import pprint 
pp=pprint.PrettyPrinter(indent=4)
import imp
import tempfile
import argparse
import random
GOOGLER="/home/devtoolsqa8/git/dailybin/bin/googler"
EDITOR = os.environ.get("EDITOR",'vim')
ASCIINEMA_DEMO="https://asciinema.org/a/6mod6437ets7l2ml7lsa9b99l"

def gen_key():
    alphabeta = {
       "Abstract": ("抽象","建模"),
       "Begin" : ("启始", "balance shift","从心开始"),
       "Combine" :("排列组合", "计算复杂度:常，对，线，平，立，指，阶"),
       "Decompose" :("分解","分类","分块"),
       "Evolve": ("演化","周期","迭代","增长"),
       "Friend/Family" : ("很感谢你能能来，不遗憾你离开","局部化"),
       "Graph":("可视化","联想","联接"),
       "Healthy" :("健康","生老病死"),
       "Interest" :("意义","复利","边际效应"),
       "Judge" :("策略","战略","稀缺","成本","选择","歧视","租","需求","弹性","价格","短缺和过剩"),
       "Keen": ("有趣","有料","有用"),
       "Limit":("奇点","边界","极限"),
       "Math":("概率","量化分析","费米计算"),
       "Network":("网络","拓扑","关系","秩"),
       "Optimize":("20/80原则","trade off","交换","优化"),
       "4P":("并行","刻意练飞","展示","推动"),
       "Question":("本质","4因5路"),
       "Recusive":("不动点","随机"),
       "Search":("近同反","外延"),
       "Unify":("统一","合并"),
       "Verify":("验证","证伪","批判"),
       "5W1H":("是什么","时间","地点","哪些人","为什么","如何"),
       "X": ("不确定","混沌"),
       "Y": ("未来","历史"),
       "Z": ("分层模块化","高维"),
       }
    for k,v in alphabeta.iteritems():
        logger.debug("{}:{}".format(k,random.choice(v)))
    return [random.choice(v) for k,v in alphabeta.iteritems()]
def test():
    cmd = [GOOGLER,"-c hk", "-n 10", "--np --json" ,"hello world"]
    out= os.popen(" ".join(cmd)).read()
    filename = "test.sh"
    with open(filename,'w') as f:
       f.write(out)
    os.system("cat test.sh")


def delete_status_line(filepath):
    temp = tempfile.TemporaryFile()
    if os.path.exists(filepath):
        with open(filepath,'r') as infile:
           in_flag = False 
           for line in infile:

               if line.startswith("keyword_list") or line.startswith("status"):
                   in_flag = not in_flag 
                   continue
               if not in_flag:
                  temp.write(line) 
        temp.seek(0)      
        with open(filepath,'w') as infile:
            map(lambda x:infile.write(x),temp.readlines())
        temp.flush()
        temp.close()
def update_Major_status(filepath):
    Major = 0 
    if os.path.exists(filepath):
        with open(filepath,'r') as infile:
           for line in infile:
               #update Q_num
               if line.startswith("#Q_"):
                  items = line.split("_")
                  #Q_0_0#:I love you
                  Major = int(items[1])
    return Major+1
def recursive_search(resultfile="test",keyword="hello"):
    Major = 0
    Minor = 0
    Prefix  = "Q"
    if os.path.exists(resultfile):
       subprocess.call([EDITOR,"+/Q_{}".format(Major),resultfile])
       rs=imp.load_source("data",resultfile) 
       status = rs.status 
       keyword_list = rs.keyword_list
       Major=update_Major_status(resultfile)
    else:
       keyword_list = [keyword]
       status = "contine"
    while True:
        if status ==".":
           break
        for keyword in keyword_list:
              
           cmd = [GOOGLER,"-c hk", "-n 10", "--np --json" ,keyword]
           logger.info(cmd)
           out= os.popen(" ".join(cmd)).read()
           delete_status_line(resultfile)
           with open(resultfile,'a+') as f:
              Q_num = "{}_{}_{}".format(Prefix,Major,Minor) 
              if Q_num == "Q_0_0":
                 f.write("# -*- coding:utf-8 -*- \n")
              f.write("######\n")
              f.write("#")
              f.write(Q_num)
              f.write(" #:")
              f.write(keyword)   
              f.write("\n")
              f.write("######\n")
              f.write(Q_num)
              f.write(" = ")
              f.write(out)
           Minor += 1    
        with open(resultfile,'a+') as f:
           f.write("keyword_list = [ \n")
           for combin_key in gen_key():
               f.write("   \"   {}\",\n".format(combin_key))
           f.write("]\n")
           f.write("status= \".\"\n")

        subprocess.call([EDITOR,"+/Q_{}".format(Major),resultfile])
        rs=imp.load_source("data",resultfile) 
        status = rs.status
        keyword_list = rs.keyword_list
        Major += 1
        Minor  = 0    

if __name__ == "__main__":
   parser = argparse.ArgumentParser(description="lgzrecursive")
   parser.add_argument('-f',help='result file',type=str,default='test.py')
   parser.add_argument('-kw',help='result file',type=str,default='人类')
   args = parser.parse_args()
   
   recursive_search(args.f,keyword=args.kw)
